// Copyright (c) 2007 The Hewlett-Packard Development Company
// Copyright (c) 2012-13 Mark D. Hill and David A. Wood
// Copyright (c) 2015 Advanced Micro Devices, Inc.
//
// All rights reserved.
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


// How is intel instruction format organized?
// https://datacadamia.com/lang/assembly/intel/modrm
// |Instruction Prefixes|Opcode|ModR/M|SIB|Displacement|Immediate|
//   Instruction Prefixes: Each prefix is 1 byte, can have >1 prefixes.
//   Opcode: 1-, 2- or 3-byte opcode.
//   ModR/M: 1 byte (if required).    
//          |7 Mod 6|5 Reg/Opcode 3|2 R/M 0|
//   SIB: 1 byte (if required).
//   Displacement: address displacement of 1, 2 or 4 bytes or none.
//   Immediate: Immediate data of 1, 2 or 4 bytes or none.


// X87 instructions begin with an opcode byte in the range 0xD8 to 0xDF.
// i.e. 0b11011000 to 0b11011111. Both has top 5 bits being 0b11011, i.e. 0x1B.
// Now we can find "0x1B", which means the following opcodes have top 5 bits
// being 0x1B. Since 1-byte opcode has 8 bits, we then need to check the rest
// 3 bits.

// Before continuing, need to understand ModRM field.
// The opcode can be followed by a mode-register-memory (ModRM) byte, which
// further describes the operation and/or operands. 
// Hence, ModRM is 1-byte long.
// ModRM may also be followed by a scale-index-base (SIB) byte, which is used
// to specify indexed register-indirect forms of memory addressing.

// http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2008/10/24594_APM_v3.pdf
// Check page 443, Table A-15.
// Take a look at instruction FSUB and FSUBR:



// The following code describes all the possiblities of the 8-bit opcode with
// the first 5 bits being 0x1B (0b11011). That is why we can see it starts with
// "0x1B: decode OPCODE_OP_BOTTOM3 ...". Indicating that we have decoded the
// first 5 bits of the opcode. Then inside that curly brace, we need to handle
// all the possibilities of the rest 3 bits.
// That is why we can see it follows by "0x0", "0x1" all the way to "0x7", since
// we need to cover those 3 bits of opcode.
// Then, inside each case (out of 8 cases), we can see there are 8 cases, which
// means we handle the following 3 bits right after the opcode. Such 3 bits lies
// in the ModRM reg Feild, hence, those 3 bits are the starting 3 bits of ModRM.

// If we look deeper, for instance, 0x1B -> 0x1 -> 0x2, we can see that there is
// a new case "0x3", but we cannot find 0x1 or 0x2, etc.. This means we are 
// trying to decode more bits (note that we have decoded opcode, and ModRM) in 
// the field right after ModRM, which is SIB (check previous comments for more 
// details), and not all instructions requires SIB field. That is why we can 
// only see 0x3, but cannot see 0x1 or 0x2.

// Now, I believe you have a basic understanding of how the code handles all
// instructions supported. Then comes a new question: how do we define all those
// cases? Based on what?
// The answer is - based on the Intel/AMD64 Architecture Programmer's Manual. In
// other words, it is already defined by the hardware companies.
// Hence, we need to refer to the manual:
// http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2008/10/24594_APM_v3.pdf

// Now, let's turn to page 443, Table A-15: x87 Opcodes and ModRM Extensions.
// On the left-most column, it shows the opcode, starting from D8, to DF on the 
// next few pages.

// Consider the instruction FSUB:
// Note: DX+ModRM/Y,Z... means a specific instruction is defined with opcode DX,
//       and such instruction has ModRM field in Yth,Zth column(s).
//       The instruction on the first row (starts with !11) means "by default";
//       But the actual instruction lies in the corresponding "11" rows.
// It is defined with more than 1 opcodes: D8+ModRM/4, DC+ModRM/4,5.
// D8 corresponds to 0x0 of the rest 3 bits. DC corresponds to 0x4 of the rest 3 bits.
// First let's focus on FSUB with opcode being D8 (p. 443):
//   D8 corresponds to 0x0 of the rest 3 bits.
//   Since it is in the 4th column of ModRM: 
//      0x1B -> 0x0 (D8) -> 0x4 (4th column) "Inst::FSUB1(Ed);"
// Then, let's focus on FSUB with opcode being DC (p. 447): 
//   DC corresponds to 0x4 of the rest 3 bits.
//   Since we can find FSUB in 4th(by default) and 5th column:
//      0x1B -> 0x4 (DC) -> 0x4 (4th column) "default: Inst::FSUB2(Mq);"
//      0x1B -> 0x4 (DC) -> 0x5 (5th column) "0x3: Inst::FSUB2(Eq);"

format WarnUnimpl {
    0x1B: decode OPCODE_OP_BOTTOM3 default Inst::UD2() {
        // opcode: 0xD8
        0x0: decode MODRM_REG {
            0x0: Inst::FADD1(Ed);
            0x1: Inst::FMUL1(Ed);
            0x2: fcom();
            0x3: fcomp();
            0x4: Inst::FSUB1(Ed);
            0x5: Inst::FSUBR1(Ed);
            0x6: Inst::FDIV1(Ed);
            0x7: fdivr();
        }
        // opcode: 0xD9
        0x1: decode MODRM_REG {
            0x0: Inst::FLD(Ed);
            0x1: decode MODRM_MOD {
                0x3: Inst::FXCH(Rq);
            }
            0x2: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x0: fnop();
                }
                default: Inst::FST(Md);
            }
            0x3: Inst::FSTP(Md);
            0x4: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x0: Inst::FCHS();
                    0x1: Inst::FABS();
                    0x4: ftst();
                    0x5: fxam();
                }
                default: Inst::FLDENV(M);
            }
            0x5: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x0: Inst::FLD1();
                    0x1: Inst::FLDL2T();
                    0x2: Inst::FLDL2E();
                    0x3: Inst::FLDPI();
                    0x4: Inst::FLDLG2();
                    0x5: Inst::FLDLN2();
                    0x6: Inst::FLDZ();
                }
                default: Inst::FLDCW(Mw);
            }
            0x6: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x0: f2xm1();
                    0x1: Inst::FYL2X();
                    0x2: Inst::FPTAN();
                    0x3: fpatan();
                    0x4: fxtract();
                    0x5: Inst::FPREM1();
                    0x6: fdecstp();
                    0x7: fincstp();
                }
                default: Inst::FNSTENV(M);
            }
            0x7: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x0: Inst::FPREM();
                    0x1: fyl2xp1();
                    0x2: fsqrt();
                    0x3: Inst::FSINCOS();
                    0x4: frndint();
                    0x5: fscale();
                    0x6: Inst::FSIN();
                    0x7: Inst::FCOS();
                }
                default: Inst::FNSTCW(Mw);
            }
        }
        //0x2: esc2();
        0x2: decode MODRM_REG {
            0x0: decode MODRM_MOD {
                0x3: fcmovb();
                default: fiadd();
            }
            0x1: decode MODRM_MOD {
                0x3: fcmove();
                default: fimul();
            }
            0x2: decode MODRM_MOD {
                0x3: fcmovbe();
                default: ficom();
            }
            0x3: decode MODRM_MOD {
                0x3: fcmovu();
                default: ficomp();
            }
            0x4: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fisub();
            }
            0x5: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x1: fucompp();
                }
                default: fisubr();
            }
            0x6: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fidiv();
            }
            0x7: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fidivr();
            }
        }
        //0x3: esc3();
        0x3: decode MODRM_REG {
            0x0: decode MODRM_MOD {
                0x3: fcmovnb();
                default: Inst::FILD(Md); // 32-bit int
            }
            0x1: decode MODRM_MOD {
                0x3: fcmovne();
                default: fisttp();
            }
            0x2: decode MODRM_MOD {
                0x3: fcmovnbe();
                default: fist();
            }
            0x3: decode MODRM_MOD {
                0x3: fcmovnu();
                default: Inst::FISTP(Md);
            }
            0x4: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x2: fnclex();
                    0x3: fninit();
                }
            }
            0x5: decode MODRM_MOD {
                // 'R' insists on having a size qualifier, so I picked 'q',
                // but I don't think it has any effect
                0x3: Inst::FUCOMI(Rq);
                // 80-bit load
                default: Inst::FLD80(M);
            }
            0x6: decode MODRM_MOD {
                0x3: Inst::FCOMI(Rq);
            }
            0x7: Inst::FST80P(M);
        }
        //0x4: esc4();
        0x4: decode MODRM_REG {
            0x0: Inst::FADD2(Eq);
            0x1: Inst::FMUL2(Eq);
            0x2: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fcom();
            }
            0x3: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fcomp();
            }
            0x4: decode MODRM_MOD {
                0x3: Inst::FSUBR2(Eq);
                default: Inst::FSUB2(Mq);
            }
            0x5: decode MODRM_MOD {
                0x3: Inst::FSUB2(Eq);
                default: Inst::FSUBR2(Mq);
            }
            0x6: decode MODRM_MOD {
                0x3: fdivr();
                default: Inst::FDIV2(Mq);
            }
            0x7: decode MODRM_MOD {
                0x3: Inst::FDIV2(Eq);
                default: fdivr();
            }
        }
        //0x5: esc5();
        0x5: decode MODRM_REG {
            0x0: decode MODRM_MOD {
                0x3: ffree();
                // 64-bit load
                default: Inst::FLD(Mq);
            }
            0x1: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fisttp();
            }
            0x2: decode MODRM_MOD {
                0x3: Inst::FST(Eq);
                default: Inst::FST(Mq);
            }
            0x3: decode MODRM_MOD {
                0x3: Inst::FSTP(Eq);
                default: Inst::FSTP(Mq);
            }
            0x4: decode MODRM_MOD {
                0x3: fucom();
                default: frstor();
            }
            0x5: decode MODRM_MOD {
                0x3: fucomp();
            }
            0x6: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fnsave();
            }
            0x7: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: Inst::FNSTSW(Mw);
            }
        }
        //0x6: esc6();
        0x6: decode MODRM_REG {
            0x0: decode MODRM_MOD {
                0x3: Inst::FADDP(Eq);
                default: fiadd();
            }
            0x1: decode MODRM_MOD {
                0x3: Inst::FMULP(Eq);
                default: fimul();
            }
            0x2: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: ficom();
            }
            0x3: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x1: fcompp();
                }
                default: ficomp();
            }
            0x4: decode MODRM_MOD {
                0x3: Inst::FSUBRP(Rq);
                default: fisub();
            }
            0x5: decode MODRM_MOD {
                0x3: Inst::FSUBP(Eq);
                default: fisubr();
            }
            0x6: decode MODRM_MOD {
                0x3: fdivrp();
                default: fidiv();
            }
            0x7: decode MODRM_MOD {
                0x3: Inst::FDIVP(Eq);
                default: fidivr();
            }
        }
        //0x7: esc7();
        0x7: decode MODRM_REG {
            0x0: decode MODRM_MOD {
                // The ffreep instruction isn't entirely real. It should work
                // the same as ffree but then also pop the register stack.
                0x3: ffreep();
                default: Inst::FILD(Mw);
            }
            0x1: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fisttp();
            }
            0x2: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: fist();
            }
            0x3: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: Inst::FISTP(Mw);
            }
            0x4: decode MODRM_MOD {
                0x3: decode MODRM_RM {
                    0x0: Inst::FNSTSW(rAw);
                }
                default: fbld();
            }
            0x5: decode MODRM_MOD {
                0x3: Inst::FUCOMIP(Rq);
                default: Inst::FILD(Mq);
            }
            0x6: decode MODRM_MOD {
                0x3: fcomip();
                default: fbstp();
            }
            0x7: decode MODRM_MOD {
                0x3: Inst::UD2();
                default: Inst::FISTP(Mq);
            }
        }
    }
}
